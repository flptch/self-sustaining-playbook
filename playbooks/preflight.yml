##
##   Copyright (c) 2020-2022 Intel Corporation.
##
##   Licensed under the Apache License, Version 2.0 (the "License");
##   you may not use this file except in compliance with the License.
##   You may obtain a copy of the License at
##
##       http://www.apache.org/licenses/LICENSE-2.0
##
##   Unless required by applicable law or agreed to in writing, software
##   distributed under the License is distributed on an "AS IS" BASIS,
##   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##   See the License for the specific language governing permissions and
##   limitations under the License.
##
---
# Preflight: ALL checks must PASS
# Only assert issues (do NOT change anything)
#
# Manual run: 'ansible-playbook -i inventory.ini playbooks/preflight.yml --flush-cache'
#
# Summary:
# On Ansible Host (localhost):
# - Check Ansible version (match)
# - Check Python version (min)
# - Check Group Vars (exist)
# - Check Host Vars (exist for each worker node)
# On All targets (k8s_cluster):
# - Check Linux Distro
# - Check Hostnames (match Inventory)
# - Check if cpusets and isolcpus are enabled simultaneously
# - Check cpusets Total (not more than actual)
# - Check cpusets IDs (valid on system)
# - Check cpusets OS Reserved (not 0,1,etc)
# - Check isolcpus Total (not more than actual)
# - Check isolcpus IDs (valid on system)
# - Check isolcpus OS Reserved (not 0,1,etc)
# On Worker Nodes Only (kube_node):
# - Check DP Interfaces (is not empty)
# - Check DP Interfaces Name (optional)
# - Check DP Interfaces Bus Info (pciid)
# - Check QAT Devices Bus Info (pciid)
# - Check QAT SRIOV VFs (max)
# - Check SGX configuration
# - Check OVS DPDK Dependencies (for 1G Hugepages)
# - Check VPP Dependencies (for 2M Hugepages)
# - Check CNI Dependencies (for OVS DPDK or VPP and Hugepages)
# - Check SST (not on RHEL 8.2 or old OSs)
# - Check Linux distro for cstates
# - Warn BIOS VT-d (should be enabled)
# - Warn BIOS Hyper-Threading (should be enabled)
# - Warn collectd (kernel update needed on old OSs)
# - Check OVS DPDK Version Compatibility (for OVS support)
# - Check Intel Ethernet Operator configuration
# - Check Intel SR-IOV FEC Operator configuration
# On Role specific Only (k8s_cluster)
# - Check MinIO requirements


# additional vars required:
#  cek_supported_ansible_base: # must be version
#  cek_supported_python: # min version
#  cek_supported_distros: [] # list
#  cek_supported_distros_versions: [] # list


##################################
# Prerequisites for Ansible Host #
##################################
- hosts: 127.0.0.1
  any_errors_fatal: true
  connection: local
  vars:
    cek_supported_ansible_base: 2.11.8
    cek_supported_python: 3

  tasks:

    - debug: msg="Ansible version is {{ ansible_version.string }}"
    - name: Check Ansible Version
      assert:
        that: (ansible_version.full is version_compare(cek_supported_ansible_base, '>='))
        msg: "Ansible version must be {{ cek_supported_ansible_base }}. Please update"

    - debug: msg="Python version is {{ ansible_python_version }}"
    - name: Check Python Version
      assert:
        that: (ansible_python_version is version_compare(cek_supported_python, '>='))
        msg: "Python version must be at least {{ cek_supported_python }}. Please update"

    - name: read Group Vars
      stat:
        path: "{{ inventory_dir }}/group_vars/"
      register: group_vars_details

    - name: Check Group Vars
      assert:
        that: "group_vars_details.stat.exists and group_vars_details.stat.isdir"
        msg: "File group_vars/all.yml does NOT exist. Must be created per Guide"

    - name: read Host Vars
      stat:
        path: "{{ inventory_dir }}/host_vars/{{ item }}.yml"
      register: host_vars_details
      with_items: "{{ groups['kube_node'] }}"

    - name: check Host Vars
      assert:
        that: "item.stat.exists and item.stat.isreg"
        msg: "File host_vars/{{ item.item }}.yml does NOT exist. Must be created per Guide"
      with_items: "{{ host_vars_details.results }}"

    - name: read VM Host Vars
      stat:
        path: "{{ inventory_dir }}/host_vars/{{ item }}.yml"
      register: vm_host_vars_details
      with_items: "{{ groups['vm_host'] }}"

    - name: check VM Host Vars
      assert:
        that: "item.stat.exists and item.stat.isreg"
        msg: "File host_vars/{{ item.item }}.yml does NOT exist. Must be created per Guide"
      with_items: "{{ vm_host_vars_details.results }}"

    - name: set group_vars_profile variable
      set_fact:
        group_vars_profile: "{{ profile_name | default('not generated') }}"

    - name: show profile_name from group_vars
      debug:
        msg: "group_vars profile_name is: '{{ group_vars_profile }}'"

    - name: set env_profile variable
      set_fact:
        env_profile: "{{ lookup('env','PROFILE') | default('not defined', True) }}"

    - name: show environment PROFILE variable
      debug:
        msg: "environment variable PROFILE is: '{{ env_profile }}'"

    - name: assert that environment variable PROFILE and group_vars profile_name matches
      assert:
        that: "env_profile == group_vars_profile"
        fail_msg: >
          "Content of environment variable 'PROFILE'='{{ env_profile }}' doesn't match
          group_vars variable 'profile_name'='{{ group_vars_profile }}', please fix this discrepancy"
      when:
        - (env_profile != 'not defined') or
          ( env_profile == 'not defined' and group_vars_profile != 'full_nfv' and vm_enabled | default(false) )

    - name: handle the error for check password less access to VM hosts
      block:
        - name: check password less access to VM hosts
          command: "ssh -o PasswordAuthentication=no {{ hostvars[item]['ip'] }} /bin/true"
          with_items: "{{ groups['vm_host'] }}"
      rescue:
        - name: Print when password less authentication failed
          debug:
            msg: >
              "Password less authentication have to be configured for all VM hosts. Use: 'ssh-copy-id <VM_host_ip>'
              See above, which one failed"
          failed_when: true
      when:
        - vm_enabled and (not on_vms | default(false))

##############################################
# Prerequisites for Control and Worker Nodes #
##############################################
- hosts: k8s_cluster,vm_host
  any_errors_fatal: true
  vars:
    cek_supported_distros: [RedHat, Rocky, Ubuntu]
    cek_supported_distros_versions: ['8.5', '20.04', '22.04']
    cpusets_ranges: []
    cpusets_discretes: []
    isolcpus_ranges: []
    isolcpus_discretes: []

  tasks:
    - name: end play for VM host
      meta: end_host
      when:
        - "'vm_host' in group_names"
        - on_vms is defined and on_vms

    - name: read Host Vars for VMs
      stat:
        path: "{{ inventory_dir }}/host_vars/{{ item.name }}.yml"
      register: vm_host_vars_details
      with_items: "{{ vms }}"
      delegate_to: localhost
      when:
        - vm_enabled and (not on_vms | default(false))
        - item.type == 'work'

    - name: check Host Vars for VMs
      assert:
        that: "item.stat.exists and item.stat.isreg"
        msg: "File host_vars/{{ item.item.name }}.yml does NOT exist. Must be created per Guide"
      with_items: "{{ vm_host_vars_details.results }}"
      when:
        - vm_enabled and (not on_vms | default(false))
        - vm_host_vars_details
        - not item.skipped | default(false)

    - name: Check VM root password
      block:
        - name: check vm_hashed_passwd presence
          assert:
            that:
              - vm_hashed_passwd is defined
            fail_msg:
              - "Variable vm_hashed_passwd is not defined"
            success_msg: "vm_hashed_passwd is present"

        - name: check vm_hashed_passwd is not a placeholder
          assert:
            that:
              - vm_hashed_passwd is defined
              - vm_hashed_passwd != "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
            fail_msg:
              - "vm_hashed_passwd was not set with hashed password. Create hashed password and run deployment again."
            success_msg: "vm_hashed_passwd verified"
      when:
        - vm_enabled and (not on_vms | default(false))

    - name: check for ip and ansible_host mismatch
      assert:
        that: "ansible_host == ip"
        msg: "Configuration mismatch detected between ansible_host={{ ansible_host }} and ip={{ ip }} on target '{{ inventory_hostname }}'"
      when:
        - ansible_host is defined
        - ip is defined
        - ansible_host | ipaddr('bool')

    - debug: msg="Linux distribution on target is {{ ansible_distribution }} {{ ansible_distribution_version }} {{ ansible_distribution_release }}"
    - name: Check Linux Distro and Version
      assert:
        that: "ansible_distribution in cek_supported_distros and ansible_distribution_version in cek_supported_distros_versions"
        msg:
          - Linux distribution {{ ansible_distribution }} {{ ansible_distribution_version }} on target '{{ inventory_hostname }}' is NOT supported
          - Must be one of {{ cek_supported_distros }} and version {{ cek_supported_distros_versions }}

#    - name: Check Linux Across Cluster
# TODO ?? Linux OS must be the same on all targets (no mix-n-match)

    - name: regather network facts in case hostname recently changed
      setup:
        gather_subset: network
    - debug: msg="Inventory target '{{ inventory_hostname }}' has the actual system hostname '{{ ansible_hostname }}'"
    - name: Check Inventory Hostnames
      debug:
        msg:
          - "Target '{{ inventory_hostname }}' in inventory does NOT match the actual system hostname '{{ ansible_hostname }}'."
          - "If it's done intentionally, please ignore this message."
      when:
        - inventory_hostname != ansible_hostname

# Early check if SELinux is configured properly
    - block:
      - name: "Collect packages facts"
        package_facts:
      - debug:
          msg:
            - "Current SELinux status:"
            - "status: {{ ansible_selinux.status | default('') }}"
            - "policy version:  {{ ansible_selinux.policyvers | default('') }}"
            - "type: {{ ansible_selinux.type | default('') }}"
            - "mode: {{ ansible_selinux.mode | default('') }}"
            - "config_mode: {{ ansible_selinux.config_mode | default('') }}"

      - name: check SELinux condition possibly causing system boot failure
        debug:
          msg:
            - "Current SELinux setup might cause the system possibly will not boot up on next reboot."
            - "Please, check SELinux settings and set it up according to the documentation."
        when:
          - "'selinux-policy' not in ansible_facts.packages"
          - "'selinux-policy-targeted' not in ansible_facts.packages"

      - name: check SELinux configuration for CRI-O runtime
        assert:
          that:
            - (ansible_selinux.status == "enabled" and selinux_state is defined and selinux_state == "disabled") or
              (ansible_selinux.status != "enabled" and selinux_state is defined and selinux_state != "enabled")
          fail_msg: "CRI-O runtime requires SELinux in disabled state. Please, set selinux_state variable to 'disabled'"
          success_msg: "CRI-O runtime SELinux configuration verified"
        when:
          - container_runtime == "crio"
      when:
        - ansible_os_family == "RedHat"

    - name: Check if CRI-O runtime is not used on Ubuntu 21.04
      assert:
        that: container_runtime != "crio"
        msg: "CRI-O runtime is not supported on Ubuntu 21.04"
      when: ansible_distribution == "Ubuntu" and ansible_distribution_version == "21.04"

    - name: check kubernetes and container runtime variables
      assert:
        that:
          - (not kubernetes and container_runtime_only_deployment) or
            (not kubernetes and not container_runtime_only_deployment)
        fail_msg: >-
          "For container runtime only deployment set container_runtime_only_deployment as "true" and kubernetes as "false".
          Set both variables as "false" to perform only host configuration."
      when:
        - not kubernetes or container_runtime_only_deployment

    - name: check k8s version
      assert:
        that: "{{ kube_version is version('v1.21', '>=') }}"
        msg: "Minimum supported k8s version is 1.21, please update kube_version variable with correct version"
      when: kubernetes and not container_runtime_only_deployment

    - name: assert that Multus is enabled in the config
      assert:
        that:
          - "kube_network_plugin_multus"
        fail_msg: "SRIOV and the Userspace CNI plugin require Multus for a fully functional cluster deployment"
      when: sriov_net_dp_enabled is defined and sriov_net_dp_enabled or
            sriov_cni_enabled is defined and sriov_cni_enabled or
            userspace_cni_enabled is defined and userspace_cni_enabled

    - name: assert that SRIOV Network Operator/SRIOV Network DP are mutually exclusive
      assert:
        that:
          - "not sriov_net_dp_enabled"
        fail_msg:
          - "SRIOV Network Operator is enabled, SRIOV Network DP/SRIOV CNI should be disabled !!"
      when: sriov_network_operator_enabled is defined and sriov_network_operator_enabled

# check cpusets CPU core/threads shielding configuration
    - block:
      - debug:
          msg:
            - cpusets_enabled = {{ cpusets_enabled }} (host_vars)
            - cpusets = {{ cpusets }} (host_vars)
            - ansible_processor_count = {{ ansible_processor_count }}
            - ansible_processor_cores = {{ ansible_processor_cores }}
            - ansible_processor_threads_per_core = {{ ansible_processor_threads_per_core }}
            - ansible_processor_vcpus = {{ ansible_processor_vcpus }}
            - CPUs Reserved for OS = 0...{{ ansible_processor_count - 1 }}
#            - CPUs Reserved for OS = {{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }} # [E207] Nested jinja pattern

      - name: check OS for cpusets based on cgroups v1 only
        assert:
          that:
            - (ansible_distribution == 'Ubuntu' and ansible_distribution_version == '20.04')
          msg:
            - Unsupported configuration.
            - CPUs isolation ('cpusets') can be only enabled on Ubuntu 20.04.x.

      - name: check CPUs isolation
        assert:
          that: ( "{{ cpusets }}" | length > 0 )
          msg:
            - Incorrect configuration. Conflicting or improper values detected
            - CPUs isolation ('cpusets') must be set according to the example file for host_vars. Please correct the configuration

      - name: split cpusets Groups
        set_fact:
          cpusets_groups: "{{ cpusets.split(',') }}"

      - debug: msg="cpusets_groups = {{ cpusets_groups }}"

      - name: filter cpusets Ranges
        set_fact:
          cpusets_ranges: "{{ cpusets_ranges + [item] }}"
        with_items: "{{ cpusets_groups }}"
        when: ("-" in item)

      - debug: msg="cpusets_ranges = {{ cpusets_ranges }}"

      - name: filter cpusets Discretes
        set_fact:
          cpusets_discretes: "{{ cpusets_discretes + [item] }}"
        with_items: "{{ cpusets_groups }}"
        when: ("-" not in item)

      - debug: msg="cpusets_discretes = {{ cpusets_discretes }}"

      - name: build cpusets List
        set_fact:
          cpusets_list: "{{ cpusets_list | default([]) | union(cpusets_discretes) | union([item]) }}"
        with_sequence: "{{ cpusets_ranges }}"

      - debug: msg="cpusets_list = {{ cpusets_list }}"

      - name: check cpusets Total
        assert:
          that: "{{ cpusets_list | length }} <= ansible_processor_vcpus"
          msg:
            - Incorrect configuration pertaining cpusets. Conflicting or improper values detected
            - The number of cpusets {{ cpusets_list | length }}, exceeds total CPUs on target {{ ansible_processor_vcpus }}. Please correct the configuration

      - name: check cpusets IDs
        assert:
          that: "item | int <= ansible_processor_vcpus"
          msg:
            - Incorrect configuration pertaining cpusets. Conflicting or improper values detected
            - The CPU ID {{ item }} set for cpusets is NOT actually present on target. Please correct the configuration
        with_items: "{{ cpusets_list }}"

      - name: check cpusets OS Reserved
        assert:
          that: "item not in cpusets_list"
          msg:
            - Incorrect configuration pertaining cpusets. Conflicting or improper values detected
            - The CPU ID 0...{{ ansible_processor_count - 1 }} should NOT be set for cpusets. Please correct the configuration
        with_items: "{{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }}"

      when:
        - cpusets_enabled is defined and cpusets_enabled | bool

# check isolcpus CPU core/threads configuration
    - block:
      - debug:
          msg:
            - isolcpus_enabled = {{ isolcpus_enabled }} (host_vars)
            - isolcpus = {{ isolcpus }} (host_vars)
            - ansible_processor_count = {{ ansible_processor_count }}
            - ansible_processor_cores = {{ ansible_processor_cores }}
            - ansible_processor_threads_per_core = {{ ansible_processor_threads_per_core }}
            - ansible_processor_vcpus = {{ ansible_processor_vcpus }}
            - CPUs Reserved for OS = 0...{{ ansible_processor_count - 1 }}
#            - CPUs Reserved for OS = {{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }} # [E207] Nested jinja pattern

      - name: check CPUs isolation
        assert:
          that: ( "{{ isolcpus }}" | length > 0 )
          msg:
            - Incorrect configuration. Conflicting or improper values detected
            - CPUs isolation ('isolcpus') must be set according to the example file for host_vars. Please correct the configuration

      - name: split isolcpus Groups
        set_fact:
          isolcpus_groups: "{{ isolcpus.split(',') }}"

      - debug: msg="isolcpus_groups = {{ isolcpus_groups }}"

      - name: filter isolcpus Ranges
        set_fact:
          isolcpus_ranges: "{{ isolcpus_ranges + [item] }}"
        with_items: "{{ isolcpus_groups }}"
        when: ("-" in item)

      - debug: msg="isolcpus_ranges = {{ isolcpus_ranges }}"

      - name: filter isolcpus Discretes
        set_fact:
          isolcpus_discretes: "{{ isolcpus_discretes + [item] }}"
        with_items: "{{ isolcpus_groups }}"
        when: ("-" not in item)

      - debug: msg="isolcpus_discretes = {{ isolcpus_discretes }}"

      - name: build isolcpus List
        set_fact:
          isolcpus_list: "{{ isolcpus_list | default([]) | union(isolcpus_discretes) | union([item]) }}"
        with_sequence: "{{ isolcpus_ranges }}"

      - debug: msg="isolcpus_list = {{ isolcpus_list }}"

      - name: check isolcpus Total
        assert:
          that: "{{ isolcpus_list | length }} <= ansible_processor_vcpus"
          msg:
            - Incorrect configuration pertaining isolcpus. Conflicting or improper values detected
            - The number of isolcpus {{ isolcpus_list | length }}, exceeds total CPUs on target {{ ansible_processor_vcpus }}. Please correct the configuration

      - name: check isolcpus IDs
        assert:
          that: "item | int <= ansible_processor_vcpus"
          msg:
            - Incorrect configuration pertaining isolcpus. Conflicting or improper values detected
            - The CPU ID {{ item }} set for isolcpus is NOT actually present on target. Please correct the configuration
        with_items: "{{ isolcpus_list }}"

      - name: check isolcpus OS Reserved
        assert:
          that: "item not in isolcpus_list"
          msg:
            - Incorrect configuration pertaining isolcpus. Conflicting or improper values detected
            - The CPU ID 0...{{ ansible_processor_count - 1 }} should NOT be set for isolcpus. Please correct the configuration
        with_items: "{{ lookup('sequence','0-{{ ansible_processor_count - 1 }}').split(',') }}"

      when:
        - isolcpus_enabled is defined and isolcpus_enabled | bool

####################################
# Prerequisites for Worker Node(s) #
####################################
- hosts: kube_node,vm_host
  any_errors_fatal: true
  vars:
    cstates_supported_distros: [Ubuntu]
    cstates_supported_distros_versions: ['22.04']
    phy_nics_pciids: []
    gpu_pciids:
      - name: DG1
        pciids: ["4907"]


  tasks:
    - name: end play for VM host
      meta: end_host
      when:
        - "'vm_host' in group_names"
        - on_vms is defined and on_vms

# STORY: "nic bus info specified is present on system"
    - debug:
        msg: "Dataplane (DP) interface(s) defined in host_vars = {{ dataplane_interfaces }}"
      when: dataplane_interfaces is defined

    - name: assert that (SRIOV Network DP/SRIOV CNI) and (SRIOV Network Operator) are mutually exclusive
      assert:
        that:
          - "not sriov_network_operator_enabled"
        fail_msg:
          - "SRIOV Network DP/SRIOV CNI is enabled, SRIOV Network Operator should be disabled !!"
      when:
        - sriov_cni_enabled or sriov_net_dp_enabled

    - name: check DP Interfaces
      assert:
        that: "dataplane_interfaces != []"
        msg: "Dataplane (DP) interface(s) on target '{{ ansible_hostname }}' must be set in host_vars. Please correct the configuration"
      when:
        - profile_name != 'build_your_own'
        - dataplane_interfaces is defined
        - (update_nic_drivers is defined and update_nic_drivers) or
          (install_ddp_packages is defined and install_ddp_packages) or
          (sriov_cni_enabled is defined and sriov_cni_enabled) or
          (sriov_network_operator_enabled is defined and sriov_network_operator_enabled)

    - debug:
        msg: "Network interfaces present on target '{{ ansible_hostname }}' = {{ ansible_interfaces }}"

    - name: read Physical NICs PCIIDs
      set_fact:
        phy_nics_pciids: "{{ phy_nics_pciids + [ ansible_facts[item]['pciid'] ] }}"
      with_items: "{{ ansible_interfaces }}"
      when: ansible_facts[item]['pciid'] is defined and ansible_facts[item]['type'] == "ether"

    - debug: msg="PCI Slots for the NICs on target '{{ ansible_hostname }}' = {{ phy_nics_pciids }}"

    - name: check DP Interfaces Bus Info
      assert:
        that: ("{{ item.bus_info }}" in "{{ phy_nics_pciids }}")
        msg: "Dataplane interface defined with PCI ID '{{ item.bus_info }}' does NOT exist on target. Please correct the configuration"
      with_items: "{{ dataplane_interfaces }}"
      when: dataplane_interfaces is defined and dataplane_interfaces != []

    - name: check invalid driver for CNDP on DP Interfaces
      assert:
        that: ("{{ item.pf_driver }}" in "['i40e', 'ice', 'iavf']")
        msg: >-
          "Dataplane interface defined with PCI ID '{{ item.bus_info }}' have unssupported pf_driver '{{ item.pf_driver }}' for CNDP.
          Please correct the configuration. Supported pf_drivers are ['i40e', 'ice', 'iavf']"
      with_items: "{{ dataplane_interfaces }}"
      when:
        - dataplane_interfaces is defined and dataplane_interfaces != []
        - cndp_dp_enabled | default(false) | bool

    - name: load firmware specific variables
      include_vars: "../roles/bootstrap/update_nic_firmware/defaults/main.yml"
      when: nvmupdate is not defined

    - name: check nic firmware version needed for loading of DDP profile
      check_nic_firmware:
        pci_id: "{{ item.bus_info }}"
        min_fw_version: "{{ nvmupdate[item.pf_driver].min_ddp_loadable_fw_version }}"
        ddp: true
      with_items: "{{ dataplane_interfaces }}"
      when:
        - dataplane_interfaces is defined and dataplane_interfaces != []
        - install_ddp_packages is defined and install_ddp_packages
        - not update_nic_firmware | default(false)

    - name: check nic firmware version needed for automatic firmware update
      check_nic_firmware:
        pci_id: "{{ item.bus_info }}"
        min_fw_version: "{{ nvmupdate[item.pf_driver].min_updatable_fw_version }}"
      with_items: "{{ dataplane_interfaces }}"
      when:
        - dataplane_interfaces is defined and dataplane_interfaces != []
        - update_nic_firmware | default(false)

    - name: Check first DP interface driver and DDP package
      block:
        - name: Check first DP interface driver
          assert:
            that: "dataplane_interfaces[0].pf_driver == ansible_facts[item]['module']"
            msg: >-
              "Dataplane interface '{{ dataplane_interfaces[0].bus_info }}' 'pf_driver' is set to '{{ dataplane_interfaces[0].pf_driver }}'.
              Please, set it to '{{ ansible_facts[item]['module'] }}'."
          loop: "{{ ansible_interfaces }}"
          when:
            - ansible_facts[item]['pciid'] is defined and ansible_facts[item]['type'] == "ether"
            - dataplane_interfaces[0].bus_info in ansible_facts[item]['pciid']

        - name: check if selected DDP package corresponds PF driver ice
          assert:
            that: "{{ dataplane_interfaces[0].ddp_profile is regex('^ice_comms*') }}"
            msg: "ddp_profile '{{ dataplane_interfaces[0].ddp_profile }}' doesn't correspond pf_driver '{{ dataplane_interfaces[0].pf_driver }}'"
          when:
            - dataplane_interfaces[0].ddp_profile is defined
            - dataplane_interfaces[0].ddp_profile | length > 0
            - dataplane_interfaces[0].pf_driver == "ice"
            - install_ddp_packages is defined and install_ddp_packages

        - name: check if selected DDP package corresponds PF driver i40e
          assert:
            that: "{{ dataplane_interfaces[0].ddp_profile in ddp_profiles_allowed }}"
            msg: "ddp_profile '{{ dataplane_interfaces[0].ddp_profile }}' doesn't correspond pf_driver '{{ dataplane_interfaces[0].pf_driver }}'"
          when:
            - dataplane_interfaces[0].ddp_profile is defined
            - dataplane_interfaces[0].ddp_profile | length > 0
            - dataplane_interfaces[0].pf_driver == "i40e"
            - install_ddp_packages is defined and install_ddp_packages
          vars:
            ddp_profiles_allowed:
              - ecpri.pkg
              - esp-ah.pkg
              - ppp-oe-ol2tpv2.pkgo
              - mplsogreudp.pkg
              - gtp.pkgo
      when:
        - dataplane_interfaces is defined and dataplane_interfaces | length > 0

    - name: check QAT Devices list is configured properly
      block:
        - debug:
            msg: "QAT device(s) defined in host_vars = {{ qat_devices }}"

        - name: read QAT PCIIDs
          shell: "set -o pipefail && lshw -businfo -numeric | egrep -i '{{ qat_supported_pf_dev_ids | join('|') }}'"
          args:
            executable: /bin/bash
          register: lshw_qat_host
          when:
            - on_vms is not defined or not on_vms

        - name: read QAT PCIIDs on VMs
          shell: "set -o pipefail && lshw -businfo -numeric | egrep -i '{{ (qat_supported_vf_dev_ids + qat_supported_pf_dev_ids) | join('|') }}'"
          args:
            executable: /bin/bash
          register: lshw_qat_vms
          when:
            - on_vms is defined and on_vms

        - name: store lshw_qat
          set_fact:
            lshw_qat: "{% if (on_vms is defined and on_vms) %}{{ lshw_qat_vms }}{% else %}{{ lshw_qat_host }}{% endif %}"

        - debug:
            msg: "QAT devices found on target = {{ lshw_qat.stdout }}"

        - name: check QAT Devices' Bus Info
          assert:
            that: ("{{ item.qat_id }}" in """{{ lshw_qat.stdout }}""")
            msg: "QAT device defined with PCI ID '{{ item.qat_id }}' does NOT exist on target. Please correct the configuration"
          with_items: "{{ qat_devices }}"
        # STORY: "qat_sriov_numvfs should not exceed max supported (16) per each dev_ID"
        - debug:
            msg:
              - qat_sriov_numvfs for {{ item.qat_id }} = {{ item.qat_sriov_numvfs }} (host_vars)
              - update_qat_drivers = {{ update_qat_drivers }} (host_vars)
          with_items: "{{ qat_devices }}"

        - name: check QAT SRIOV VFs
          assert:
            that: ({{ item.qat_sriov_numvfs }} <= 16)
            msg:
              - Incorrect configuration pertaining QAT SRIOV. Conflicting or improper values detected
              - When SRIOV VFs are set for QAT, max value is 16 for each ID (max 48 total per card). Please correct the configuration
          with_items: "{{ qat_devices }}"
      when:
        - update_qat_drivers is defined and update_qat_drivers
        - qat_devices is defined and qat_devices != []

# Check GPU availability and preparation, the pre-defined product PCIID can be found in i915_pciids.h of kernel source tree, only DG1 is available now.
    - name: Create empty setting list for configure_gpu on the worker node
      set_fact:
        setting_list: []

    - name: Create configure_gpu setting list for the worker node
      set_fact:
        setting_list: "{{ setting_list | default([]) + [hostvars[item].configure_gpu | default(false) | bool] }}"
      with_items:
        - "{{ groups['kube_node'] }}"

    - name: Validate configure_gpu settings when gpu_dp_enabled is false
      assert:
        that: ((setting_list | unique | length == 1) and not setting_list[0])
        msg: "Since gpu_dp_enabled is false, configure_gpu must set all false on the node with GPU"
      when:
        - gpu_dp_enabled is defined and not gpu_dp_enabled
        - setting_list | length > 0

    - name: Validate configure_gpu settings when gpu_dp_enabled is true
      assert:
        that: (setting_list | unique | length > 1) or ((setting_list | unique | length == 1) and setting_list[0])
        msg: "When gpu_dp_enabled is true, configure_gpu must set true at least on one node with GPU.  Please correct the configuration."
      when:
        - gpu_dp_enabled is defined and gpu_dp_enabled
        - setting_list | length > 0

    - name: Check Intel discrete GPU devices on node and GPU features configuration.
      block:
        - name: Read GPU Device info from node for GPU check since configure_gpu set to true
          command: "lshw -c display -businfo -numeric"
          register: lshw_gpu_hardware

        - name: Show GPU device information found from nodes
          debug:
            msg: |
              - "Retrieved GPU device info from node {{ inventory_hostname }}"
              - "{{ lshw_gpu_hardware.stdout }}"

        - name: Check each node for Intel discrete GPU
          assert:
            that: "lshw_gpu_hardware.stdout | regex_search('8086:\\d{4}') != none"
            msg: "Node {{ inventory_hostname }} doesn't have Intel discrete GPU, please set configure_gpu false for this node."

        - name: Validate the PCIID from each node is supported
          assert:
            that: "'{{ (item[1] | regex_search('8086:\\d{4}')).split(':')[1] }}' in item[0].pciids"
            msg:
              - "{{ (item[1] | regex_search('8086:\\d{4}')).split(':')[1] }} from "
              - "  {{ inventory_hostname }} is not in the pre-defined PCIID list of {{ item[0].name }}"
          with_nested:
            - "{{ gpu_pciids }}"
            - "{{ lshw_gpu_hardware.stdout_lines }}"
          when: " item[1] | regex_search('8086:\\d{4}') != none "
      when:
        - configure_gpu is defined and configure_gpu

# At this point, we did dependencies and hardware checks, so we are preparing to deploy kernel update
# GPU DP Fractional Resources must be passed in correct format
    - name: check if the GPU max memory is passed in correct format
      assert:
        that:
          - "{{ gpu_dp_max_memory.split(' ') | length == 2 }}"  # value is passed in format <value><space><unit>
          - "{{ gpu_dp_max_memory.split(' ')[1] in ['GB', 'MB', 'KB', 'Kb'] }}"  # supported units
        fail_msg: "Please provide variable value in correct format. Use <value><space><unit> format, e.g. '8 GB'"
      when: gpu_dp_max_memory is defined

# OpenSSL & OpenSSL*Engine must only be configured / installed when update_qat_drivers is set to 'true' and qat_devices is defined in host vars
    - name: check OpenSSL and OpenSSL*Engine requirements
      assert:
        that:
          - update_qat_drivers
          - qat_devices is defined and qat_devices != []
        fail_msg: "OpenSSL & OpenSSL*Engine will only configured if update_qat_drivers is set to 'true' & qat_devices is defined in host vars"
        success_msg: "OpenSSL & OpenSSL*Engine verification completed"
      when: openssl_install is defined and openssl_install

    - name: check KMRA sgx_dp requirements
      assert:
        that:
          - sgx_dp_enabled
        fail_msg: "KMRA installation requires sgx_dp_enabled set to 'true'"
        success_msg: "KMRA requirements verified"
      when: kmra.ctk_loadkey_demo.enabled | default(false)

    - name: check Intel SGX DP configuration
      assert:
        that:
          - configure_sgx is defined
          - configure_sgx
        fail_msg:
            - "Please set configure_sgx to true in host vars to allow SGX configuration on the system"
      when:
        - sgx_dp_enabled is defined and sgx_dp_enabled

    - name: check NFD configuration
      assert:
        that:
          - nfd_enabled
        fail_msg: "Deployment of Intel Device Plugins requires nfd_enabled set to 'true' in group_vars"
        success_msg: "NFD configuration verified"
      when: 
        - (qat_dp_enabled | default(false)) or
          (sgx_dp_enabled | default(false)) or
          (gpu_dp_enabled | default(false))

    - name: check kmra.pccs.api_key presence
      assert:
        that:
          - kmra.pccs.api_key is defined
        fail_msg:
          - "Variable kmra.pccs.api_key is not defined"
        success_msg: "kmra.pccs.api_key presence is verified"
      when:
        - kmra.pccs.enabled | default(false)

    - name: check PCCS API key length
      assert:
        that:
          - kmra.pccs.api_key | length == 32
        fail_msg: "PCCS API Key should be 32 bytes long"
        success_msg: "PCCS API key length verified"
      when:
        - kmra.pccs.enabled | default(false)

    - name: check PCCS API key is not a placeholder
      assert:
        that:
          - kmra.pccs.api_key is defined
          - kmra.pccs.api_key != "ffffffffffffffffffffffffffffffff"
        fail_msg:
          - "Please, visit https://api.portal.trustedservices.intel.com/provisioning-certification and click on 'Subscribe'"
          - "to generate PCCS API key."
          - "PCCS API key is essential for KMRA PCCS deployment and usage."
        success_msg: "PCCS API key verified"
      when:
        - kmra.pccs.enabled | default(false)

    - name: aesmd-demo shouldn't be enabled if tcs is enabled
      assert:
        that: not sgx_aesmd_demo_enable | default(false)
        fail_msg: "Please, set 'sgx_aesmd_demo_enable' to 'false' because it conflicts with on-host aesmd daemon required by TCS."
      when:
        - tcs.enabled | default(false)

# Validate Hugepage settings
    - name: validate hugepage settings
      block:
        - name: validate default hugepage size setting
          assert:
            that: default_hugepage_size == "2M" or default_hugepage_size == "1G"
            fail_msg: "Valid sizes for hugepage are: [2M, 1G], given: {{ default_hugepage_size }}."

        - name: validate that at least one 1G hugepage is requested
          assert:
            that: number_of_hugepages_1G > 0
            fail_msg: "number_of_hugepages_1G should not be equal to 0. Please update host vars settings."
          when: default_hugepage_size == "1G"

        - name: validate that at least one 2M hugepage is requested
          assert:
            that: number_of_hugepages_2M > 0
            fail_msg: "number_of_hugepages_2M should not be equal to 0. Please update host vars settings."
          when: default_hugepage_size == "2M"
      when: hugepages_enabled | default(false) | bool

# STORY: "vpp/ovsdpdk require hugepage enabled and configured"
    - debug:
        msg:
          - vpp_enabled = {{ vpp_enabled }} (host_vars)
          - example_net_attach_defs = {{ example_net_attach_defs }} (group_vars/all.yml)
          - userspace_ovs_dpdk = {{ example_net_attach_defs['userspace_ovs_dpdk'] }} (group_vars/all.yml)
          - userspace_vpp = {{ example_net_attach_defs['userspace_vpp'] }} (group_vars/all.yml)
          - sriov_net_dp = {{ example_net_attach_defs['sriov_net_dp'] }} (group_vars/all.yml)
          - userspace_cni_enabled = {{ userspace_cni_enabled }} (host_vars)
          - sriov_cni_enabled = {{ sriov_cni_enabled }} (host_vars)
          - sriov_network_operator_enabled = {{ sriov_network_operator_enabled }} (host_vars)
          - bond_cni_enabled = {{ bond_cni_enabled }} (host_vars)
          - ovs_dpdk_enabled = {{ ovs_dpdk_enabled }} (host_vars)
          - userspace_cni_enabled = {{ userspace_cni_enabled }} (host_vars)
          - hugepages_enabled = {{ hugepages_enabled }} (host_vars)
          - default_hugepage_size = {{ default_hugepage_size }} (host_vars)
          - number_of_hugepages_1G = {{ number_of_hugepages_1G }} (host_vars)
          - number_of_hugepages_2M = {{ number_of_hugepages_2M }} (host_vars)
      when: vpp_enabled is defined and vpp_enabled # host_vars

    - name: check OVS DPDK Dependencies
      assert:
        that: >-
          ({{ ovs_dpdk_enabled }} and not {{ vpp_enabled }} and {{ hugepages_enabled }} and
          "{{ default_hugepage_size }}" == "1G" and {{ number_of_hugepages_1G }} >= 0)
          or {{ vpp_enabled }}
        msg:
          - Incorrect configuration pertaining OVS DPDK. Conflicting or improper values detected
          - When OVS DPDK is enabled, VPP must be disabled and default_hugepage_size must be set to 1G according to host_vars example.
          - Also check these conditions in group_vars, example_net_attach_defs['userspace_ovs_dpdk']=true, example_net_attach_defs['userspace_vpp']=false.
          - Please correct the configuration
      when: ovs_dpdk_enabled is defined and ovs_dpdk_enabled

    - name: check VPP Dependencies
      assert:
        that: >-
          ({{ vpp_enabled }} and not {{ ovs_dpdk_enabled }} and {{ hugepages_enabled }} and
          "{{ default_hugepage_size }}" == "2M" and {{ number_of_hugepages_2M }} >= 0)
          or {{ ovs_dpdk_enabled }}
        msg:
          - Incorrect configuration pertaining VPP. Conflicting or improper values detected
          - When VPP is enabled, OVS DPDK must be disabled and default_hugepage_size must be set to 2M according to host_vars example.
          - Also check these conditions in group_vars, example_net_attach_defs['userspace_ovs_dpdk']=false, example_net_attach_defs['userspace_vpp']=true.
          - Please correct the configuration.
      when: vpp_enabled is defined and vpp_enabled


# STORY: "cnis require net-attach-defs to be enabled"
    - name: check CNI Config
      assert:
        that: >-
          ({{ userspace_cni_enabled }} and {{ ovs_dpdk_enabled }} and {{ example_net_attach_defs['userspace_ovs_dpdk'] }} and not {{ vpp_enabled }} and
          not {{ example_net_attach_defs['userspace_vpp'] }} and {{ hugepages_enabled }} and
          "{{ default_hugepage_size }}" == "1G" and {{ number_of_hugepages_1G }} >= 0)
          or ({{ userspace_cni_enabled }} and not {{ ovs_dpdk_enabled }} and not {{ example_net_attach_defs['userspace_ovs_dpdk'] }} and {{ vpp_enabled }}
          and {{ example_net_attach_defs['userspace_vpp'] }} and {{ hugepages_enabled }} and
          "{{ default_hugepage_size }}" == "2M" and {{ number_of_hugepages_2M }} >= 0)
        msg:
          - Incorrect configuration pertaining CNI. Conflicting or improper values detected.
          - When Userspace CNI is enabled, either OVS DPDK or VPP must be enabled, default_hugepage_size must also set under these options.
          - 1. If VPP is enabled, ovs_dpdk_enabled=false, default_hugepage_size = 2M in host_vars; and
          -      example_net_attach_defs['userspace_ovs_dpdk']=false, example_net_attach_defs['userspace_vpp']=true in group_vars.
          - 2. If OVS DPDK is enabled, default_hugepage_size = 1G in host_vars; and
          -      vpp_enabled=false, example_net_attach_defs['userspace_ovs_dpdk']=true, example_net_attach_defs['userspace_vpp']=false in group_vars.
          - Please correct the configuration.
      when: userspace_cni_enabled is defined and userspace_cni_enabled


# STORY: "If SST enabled, confirm minimum kernel or kernel_update specified"
    - name: check platform before SST-PP verification
      command: "cat /sys/devices/cpu/caps/pmu_name"
      when: sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled
      changed_when: true
      register: verify_platform_for_sst_pp

    - name: check Intel(R) SST-PP (feature perf-profile) requirements
      assert:
        that:
          - ansible_distribution == 'Ubuntu' and ansible_distribution_version >= '20.04' or
            (ansible_distribution in ['RedHat', 'Rocky', 'CentOS'] and ansible_distribution_version >= '8.3')
          - turbo_boost_enabled
        fail_msg:
            - "Playbook terminated cause of failure might to two reasons: Firstly, SST-PP is only supported in RedHat / Rocky >= 8.3 or Ubuntu >=20.04"
            - "To proceed further make sure sst_bf_configuration_enabled, sst_cp_configuration_enabled,"
            - "sst_tf_configuration_enable & sst_pp_configuration_enabled all should be disabled in host_vars"
            - "Secondly, make sure turbo_boost_enabled in host_vars is set to 'true', as required for turbo-freq configuration"
        success_msg: "Intel(R) SST-PP (feature perf-profile), verification completed"
      when:
        - sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled
        - "'skylake' not in verify_platform_for_sst_pp.stdout"

    - name: Intel(R) SST-PP (feature perf-profile) not available
      fail:
        msg:
          - "SST-PP is not supported on {{ verify_platform_for_sst_pp.stdout }} platform"
          - "Make sure sst_pp_configuration_enabled is set to false in host vars"
      when:
        - sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled
        - "'skylake' in verify_platform_for_sst_pp.stdout"


# Cstates are supported only with kernel version >= 5.13
    - name: Check if distribution is supported by cstates
      assert:
        that: "ansible_distribution in cstates_supported_distros and ansible_distribution_version in cstates_supported_distros_versions"
        msg:
          - Linux distribution {{ ansible_distribution }} {{ ansible_distribution_version }} on target '{{ inventory_hostname }}' does NOT support cstates
          - Must be one of {{ cstates_supported_distros }} and version {{ cstates_supported_distros_versions }}
      when: cstate_enabled is defined and cstate_enabled


# Uncore frequency scaling is supported only with kernel version >= 5.13
    - name: Check if distribution is supported by uncore frequency scaling
      assert:
        that: "ansible_distribution in cstates_supported_distros and ansible_distribution_version in cstates_supported_distros_versions"
        msg:
          - Linux distribution {{ ansible_distribution }} {{ ansible_distribution_version }} on target '{{ inventory_hostname }}'
          - does NOT support uncore frequency scaling
          - Must be one of {{ cstates_supported_distros }} and version {{ cstates_supported_distros_versions }}
      when: ufs_enabled is defined and ufs_enabled


# STORY: Intel VT-d should be enabled in BIOS
    - name: check Intel VT-d on BMs
      block:
        - name: Check Intel VT-d
          shell: "set -o pipefail && dmesg | grep DMAR | grep remapping"
          args:
            executable: /bin/bash
          register: dmesg_dmar_remap
          changed_when: False

        - debug: msg="dmesg >> {{ dmesg_dmar_remap.stdout }}"

        - name: warn about Intel VT-d
          fail:
            msg: "Warning: Intel VT-d appears DISABLED on target.  Please check BIOS under 'Advanced > Integrated IO Configuration' and Enable if necessary"
          when:
            - dmesg_dmar_remap.stdout|length  == 0
      when:
        - on_vms is not defined or not on_vms

# STORY: CPU Hyper-Threading should be enabled in BIOS
    - name: warn about Hyper-Threading
      fail:
        msg: "Warning: CPU Hyper-Threading is DISABLED on target.  Please check BIOS under 'Advanced > Processor Configuration' and Enable if necessary"
      when: ansible_processor_threads_per_core != 2

# STORY: "collectd and telegraf are mutually exclusive"
    - name: fail if collectd and telegraf are both enabled
      assert:
        that: >-
          (({{ collectd_enabled | bool }}) and (not ({{ telegraf_enabled | bool }})))
          or (not {{ collectd_enabled | bool }} and {{ telegraf_enabled | bool }})
          or (not {{ collectd_enabled | bool }} and (not ({{ telegraf_enabled | bool }})))
        msg: "CollectD and Telegraf are mutually exclusive, please enable only one."
      when:
        - collectd_enabled is defined
        - telegraf_enabled is defined

# STORY: "supported k8s versions require istio in >= 1.10"
    - name: fail if istio version is not compatible with current k8s version
      assert:
        that:
          - "{{ service_mesh.version is version('1.10', '>=') }}"
        msg: |
          "Selected Istio service mesh version: '{{ service_mesh.version }}' is not compatible with selected k8s version: '{{ kube_version }}'"
          "Please, refer to the compatibility table at https://istio.io/latest/docs/releases/supported-releases/"
      when:
        - kubernetes
        - not container_runtime_only_deployment
        - service_mesh is defined
        - service_mesh.version is defined
# STORY: "TCS depends on KMRA AppHSM and KMRA PCCS"
    - name: check if KMRA Apps are enabled when TCS is enabled
      assert:
        that:
          - "{{ kmra.apphsm.enabled | default(false) }}"
          - "{{ kmra.pccs.enabled | default(false) }}"
        msg: "KMRA AppHSM and PCCS applications should be enabled in order to have TCS functional."
      when:
        - tcs.enabled | default(false) or tca.enabled | default(false)
        - configured_arch in ['icx', 'spr']

# STORY: "TCA depends on TCS"
    - name: check if TCS is enabled when TCA enabled
      assert:
        that:
          - "{{ tcs.enabled | default(false ) }}"
        msg: "TCS should be enabled in order to have TCA functional."
      when:
        - tca.enabled | default(false)
        - configured_arch in ['icx', 'spr']

# STORY: "service_mesh.sgx_signer' option is available only for icx and spr platforms"
    - name: particular service mesh options are available only for specific platforms
      assert:
        that:
          - "{{ not service_mesh.sgx_signer.enabled | default(false) }}"
        msg: "'service_mesh.sgx_signer' option is not available for the configured platform architecture."
      when:
        - service_mesh.enabled | default(false)
        - configured_arch not in ['icx', 'spr']

# STORY: TCS is available only for icx and spr platforms"
    - name: TCS is available only for specific platforms
      assert:
        that:
          - "{{ not tcs.enabled | default(false) }}"
        msg: "TCS is not available for the configured platform architecture."
      when:
        - configured_arch not in ['icx', 'spr']

# STORY: TCA is available only for icx and spr platforms"
    - name: TCA is available only for specific platforms
      assert:
        that:
          - "{{ not tca.enabled | default(false) }}"
        msg: "TCA is not available for the configured platform architecture."
      when:
        - configured_arch not in ['icx', 'spr']

# STORY: "service_mesh.sgx_signer' option depends on KMRA AppHSM, KMRA PCCS, TCS, TCA"
    - name: check if KMRA Apps, TCS and TCA are enabled when service mesh sgx_signer option is enabled
      assert:
        that:
          - "{{ kmra.apphsm.enabled | default(false) }}"
          - "{{ kmra.pccs.enabled | default(false) }}"
          - "{{ tcs.enabled | default(false ) }}"
          - "{{ tca.enabled | default(false ) }}"
        msg: "In order to use service mesh sgx-signer option, please, enable KMRA AppHSM, KMRA PCCS, TCS, TCA."
      when:
        - service_mesh.sgx_signer.enabled | default(false)
        - configured_arch in ['icx', 'spr']

# STORY: TEMPORARY: "ovs dpdk version requirements"
    - debug:
        msg:
          - install_dpdk = {{ install_dpdk }} (host_vars)
          - dpdk_version = {{ dpdk_version }} (host_vars)
          - ovs_dpdk_enabled = {{ ovs_dpdk_enabled }} (host_vars)
          - ovs_version = {{ ovs_version }} (host_vars)
      when:
        - install_dpdk is defined #host_vars
        - dpdk_version is defined #host_vars
        - ovs_version is defined #host_vars
        - ovs_dpdk_enabled is defined and ovs_dpdk_enabled #host_vars

    - name: check OVS DPDK compatibility
      assert:
        that:
          (ovs_version >= 'v2.17.0' and ovs_version <= 'v2.17.1') and (dpdk_version >= '21.11' and dpdk_version <= '22.03')
          or (ovs_version < 'v2.16.2' and ovs_version >= 'v2.16.0') and dpdk_version == '21.08'
          or ovs_version == 'v2.15.0' and dpdk_version == '20.11'
          or ovs_version == 'v2.14.2' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.14.1' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.14.0' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.13.3' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.13.2' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.13.1' and dpdk_version == '19.11.6'
          or ovs_version == 'v2.13.0' and dpdk_version == '19.11.6'
        msg: "OVS {{ ovs_version }} does not build with DPDK version {{ dpdk_version }}. Please correct the host_vars configuration"
      when:
        - dpdk_version is defined #host_vars
        - ovs_version is defined #host_vars
        - ovs_dpdk_enabled is defined and ovs_dpdk_enabled #host_vars

    - name: check settings for Intel Power Operator
      assert:
        that:
          - intel_power_manager.power_profiles | length > 0
          - intel_power_manager.power_nodes | length > 0
        fail_msg: "Intel Power Operator is enabled, but either Power Profiles or Power Nodes are not specified in group vars."
      when: intel_power_manager is defined and intel_power_manager.enabled

    - name: check if power_nodes are available in inventory
      assert:
        that:
          - item in groups['kube_node']
        fail_msg: "Intel Power Operator power_nodes have to be present in inventory. '{{ item }}' is not there: {{ groups['kube_node'] }}"
      loop: "{{ intel_power_manager.power_nodes }}"
      when: intel_power_manager is defined and intel_power_manager.enabled

    - name: check if Intel Power Operator is enabled, the ISST features should be disabled
      assert:
        that:
          - not (sst_bf_configuration_enabled is defined and sst_bf_configuration_enabled or
            sst_cp_configuration_enabled is defined and sst_cp_configuration_enabled or
            sst_tf_configuration_enabled is defined and sst_tf_configuration_enabled or
            sst_pp_configuration_enabled is defined and sst_pp_configuration_enabled)
        fail_msg:
          - "Currently Intel Power Operator and Intel SST features are mutually exclusive."
          - "Please disable ISST (SST-BF, SST-CP, SST-TF and SST-PP) in host vars."
      when: intel_power_manager is defined and intel_power_manager.enabled

    - name: check if Intel Power Operator is build locally on containerd/cri-o runtime
      assert:
        that: intel_power_manager.build_image_locally
        fail_msg:
          - "Currently Intel Power Operator must be build locally on containerd and cri-o runtime"
          - "Please set build_image_locally as true in Intel Power Operator settings"
      when: intel_power_manager is defined and intel_power_manager.enabled and container_runtime in ["crio", "containerd"]

    - name: check Intel Ethernet Operator configuration
      include_role:
        name: intel_ethernet_operator
        tasks_from: preflight_ethernet_operator
      when: intel_ethernet_operator_enabled

    - name: make sure isolcpus and cpusets are not enabled simultaneously
      assert:
        that:
          - (not isolcpus_enabled and cpusets_enabled) or
            (isolcpus_enabled and not cpusets_enabled)
        msg:
         - "isolcpus_enabled and cpusets_enabled can't be enabled simultaneously."
         - "Please correct the host_vars configuration for target '{{ ansible_hostname }}'"
      when:
        - (isolcpus_enabled is defined and isolcpus_enabled) or
          (cpusets_enabled is defined and cpusets_enabled)

# FEC Operator is only intended for the 'access'/'full_nfv'/'byo' profiles, on Ubuntu 22.04, and requires FEC Acc H/W on Host(s)
    - name: Check Intel SR-IOV FEC Operator configuration
      block:
        - name: FEC Operator - check profile is access or bring_your_own
          assert:
            that: profile_name in ['access', 'full_nfv', 'bring_your_own']
            msg: >
              "Deploying the Intel SR-IOV FEC Operator is supported only in the 'access', 'full_nfv', or 'byo' profiles.
              Please correct the group_vars configuration"

        - name: FEC Operator - check distro is Ubuntu 22.04 (generic or realtime)
          assert:
            that: ansible_distribution_version == "22.04"
            msg: "Deploying the Intel SR-IOV FEC Operator is supported only on Ubuntu 22.04. Please change the o/s or correct group_vars configuration"

        - debug: msg="fec_acc is {{ fec_acc }}"

        - name: FEC Operator - check h/w acc is configured
          assert:
            that: fec_acc is defined
            msg: "Deploying the Intel SR-IOV FEC Operator requires defining the PCIID of the ACC H/W to use. Please correct the host configuration"

        - name: FEC Operator - check runtime is docker
          assert:
            that: container_runtime == 'docker'
            msg: "Deploying the Intel SR-IOV FEC Operator is supported only for docker runtime. Please correct the group_vars configuration"

# TODO
#        - name: FEC Operator - check Cert Manager is enabled
#          assert:
#            that: cert_manager_enabled
#            msg: "Deploying the Intel SR-IOV FEC Operator requires Cert Manager to be present. Please correct the group_vars configuration"
#
#        - debug: msg="iommu_cmdline is {{ iommu_cmdline }}"
#
#        - name: FEC Operator - check host IOMMU is set in passthrough mode
#          assert:
#            that: iommu_enabled and ("iommu=pt" in iommu_cmdline)
#            msg: "Deploying the Intel SR-IOV FEC Operator requires Cert Manager to be present. Please correct the group_vars configuration"
#
#        - name: check acc h/w
#          assert:
#            that: fec_acc PCIID is present in the host and its DevID in supported list
#            msg: "Deploying the Intel SR-IOV FEC Operator requires the ACC card to be present in the host. Please correct the host h/w configuration"

      when: intel_sriov_fec_operator_enabled | default(false) | bool

    - name: check Intel FlexRAN requirements
      include_role:
        name: intel_flexran
        tasks_from: flexran_preflight
      when: intel_flexran_enabled | default(false)

####################################
# Prerequisites for Role specific  #
####################################
- hosts: k8s_cluster
  tasks:

# STORY: "MinIO requires number of nodes should be more than the minimum number of nodes defined in group_vars/all/minio_tenant_servers"
    - name: check MinIO configuration
      include_role:
        name: minio_install
        tasks_from: preflight_minio_main
      when:
        - kubernetes
        - minio_enabled is defined and minio_enabled

    - meta: end_play
#    - name: Print all variables/facts known for a host
#      ansible.builtin.debug:
#        var: hostvars[inventory_hostname]
#        verbosity: 4
